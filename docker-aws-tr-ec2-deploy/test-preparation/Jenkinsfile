// Define the function as a Closure at the top of your pipeline script
def createJsonArray = { names ->
    return "[${names.collect { "\"${it}\"" }.join(',')}]"
}

pipeline {
    agent any
    environment {
        // Set from the global environment variable
        // to extract environment variables.
        JENKINS_ENV_FILE_PATH = "${env.JENKINS_ENV_FILE_PATH}"

        EC2_TEST_BASE_NAME = "clock-test-${env.BUILD_NUMBER}"
        EC2_PRODUCTION_BASE_NAME = "clock-production-${env.BUILD_NUMBER}"
    }

    stages {
        stage('Load Jenkins Environment Variables') {
            steps {
                script {
                    try {
                        def envFilePath = env.JENKINS_ENV_FILE_PATH
                        def props = readProperties file: envFilePath
                        env.DOCKER_HUB_CREDENTIALS_ID = props.DOCKER_HUB_CREDENTIALS_ID
                        env.CLOCK_PROJ_GIT_REPO_URL = props.CLOCK_PROJ_GIT_REPO_URL
                        env.CLOCK_PROJ_DOCKER_ENV_FILE_PATH = props.CLOCK_PROJ_DOCKER_ENV_FILE_PATH
                        env.CLOCK_PROJ_AWS_ENV_FILE_PATH = props.CLOCK_PROJ_AWS_ENV_FILE_PATH
                        env.GIT_CREDENTIALS_ID = props.GIT_CREDENTIALS_ID
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Load Jenkins Environment Variables'): ${e.message}")
                    }
                }
            }
        }

        stage('Load Docker Environment Variables') {
            steps {
                script {
                    try {
                        def dockerEnvProps = readProperties file: env.CLOCK_PROJ_DOCKER_ENV_FILE_PATH

                        env.DOCKER_REGISTRY = dockerEnvProps.DOCKER_REGISTRY

                        env.CHROME_DRIVER_VERSION = dockerEnvProps.CHROME_DRIVER_VERSION
                        env.CHROME_DRIVER_PATH = dockerEnvProps.CHROME_DRIVER_PATH
                        env.PYTHONPATH = dockerEnvProps.PYTHONPATH
                        env.SELENIUM_HEADLESS_MODE_DISPLAY_PORT = dockerEnvProps.SELENIUM_HEADLESS_MODE_DISPLAY_PORT
                        env.CONTAINER_APP_PORT = dockerEnvProps.CONTAINER_APP_PORT
                        env.PUBLISHED_TEST_APP_PORT = dockerEnvProps.PUBLISHED_TEST_APP_PORT
                        env.PUBLISHED_PROD_APP_PORT = dockerEnvProps.PUBLISHED_PROD_APP_PORT
                        env.IMAGE_NAME = dockerEnvProps.IMAGE_NAME
                        env.WORKDIR = dockerEnvProps.WORKDIR

                        env.UPDATE_CLOCK_TIME_INTERVAL = dockerEnvProps.UPDATE_CLOCK_TIME_INTERVAL
                        env.CLOCK_APP_URL = dockerEnvProps.CLOCK_APP_URL
                        env.REFRESH_INTERVAL = dockerEnvProps.REFRESH_INTERVAL
                        env.TIME_FORMAT = dockerEnvProps.TIME_FORMAT
                        env.TEST_OUTPUT_FILE_PATH = dockerEnvProps.TEST_OUTPUT_FILE_PATH
                        env.PROD_OUTPUT_FILE_PATH = dockerEnvProps.PROD_OUTPUT_FILE_PATH
                        env.TEST_CONTAINER_NAME = dockerEnvProps.TEST_CONTAINER_NAME
                        env.PROD_CONTAINER_NAME = dockerEnvProps.PROD_CONTAINER_NAME
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Load Docker Environment Variables'): ${e.message}")
                    }
                }
            }
        }

        stage('Load AWS ECR Environment Variables') {
            steps {
                script {
                    try {
                        def awsEnvProps = readProperties file: env.CLOCK_PROJ_AWS_ENV_FILE_PATH
                        env.AWS_CREDENTIALS_ID = awsEnvProps.AWS_CREDENTIALS_ID
                        env.AWS_REGION = awsEnvProps.AWS_REGION
                        env.EC2_USER = awsEnvProps.EC2_USER
                        env.SSH_KEY_ID = awsEnvProps.SSH_KEY_ID

                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Load AWS Environment Variables'): ${e.message}")
                    }
                }
            }
        }

        stage('Git Clone Repo') {
            steps {
                script {
                    try {
                        echo 'Git Clone Repo'
                        git branch: 'main',
                            url: "${env.CLOCK_PROJ_GIT_REPO_URL}",
                            credentialsId: "${env.GIT_CREDENTIALS_ID}"
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Set Git Commit Hash'): ${e.message}")
                    }
                }
            }
        }

        stage('Set Git Commit Hash') {
            steps {
                script {
                    try {
                        env.GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                        echo "Short commit hash: ${env.GIT_COMMIT_SHORT}"
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Set Git Commit Hash'): ${e.message}")
                    }
                }
            }
        }

        stage('Login to Docker to AWS ECR') {
            steps {
                script {
                    try {
                        sh """
                        # Authenticate Docker to ECR (no explicit login required with IAM roles)
                        aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws
                        """
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Login to Docker to AWS ECR'): ${e.message}")
                    }
                }
            }
        }

        stage('Tester stage') {
            steps {
                script {
                    try {
                        echo 'Build docker images, run container and test'
                        sh """
                            docker --debug build --target tester \
                                   -t ${env.IMAGE_NAME}:test-${env.GIT_COMMIT_SHORT} .
                            docker run --rm \
                                -d --name ${env.TEST_CONTAINER_NAME} \
                                -e WORKDIR=${env.WORKDIR} \
                                -e CONTAINER_APP_PORT=${env.CONTAINER_APP_PORT} \
                                -e CHROME_DRIVER_VERSION=${env.CHROME_DRIVER_VERSION} \
                                -e OUTPUT_FILE_PATH=${env.TEST_OUTPUT_FILE_PATH} \
                                -p ${env.PUBLISHED_TEST_APP_PORT}:${env.CONTAINER_APP_PORT}  \
                                ${env.IMAGE_NAME}:test-${env.GIT_COMMIT_SHORT}

                            docker images | grep clock || true
                            # docker image push ${env.IMAGE_NAME}:test-${env.GIT_COMMIT_SHORT}

                        """
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Tester stage'): ${e.message}")
                    }
                }
            }
        }

        stage('Production image') {
            steps {
                script {
                    try {
                        echo 'Push test and production docker images'
                        sh """
                            docker --debug build --target production \
                                -t ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT} .

                            docker images | grep clock || true
                            docker image push ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT}
                        """
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error "Failed on stage('Production image') : ${e.message}"
                    }
                }
            }
        }

        stage('Jenkins Server Cleaning') {
            steps {
                script {
                    try {
                        echo 'Cleaning....'
                        sh """
                           # docker rmi ${env.IMAGE_NAME}:test-${env.GIT_COMMIT_SHORT} || true
                           # docker rmi ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT} || true
                           # Prune any dangling images
                           # docker image prune -f || true
                        """
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error "Failed on stage('Cleaning'): ${e.message}"
                    }
                }
            }
        }

//         stage('Production Deploy on EC2') {
//             steps {
//                 script {
//                     withAWS(credentials: env.AWS_CREDENTIALS_ID, region: env.AWS_REGION) {
//                         sshagent(credentials: [env.SSH_KEY_ID]) {
//                             sh """
//                                 ssh -o StrictHostKeyChecking=no ${env.EC2_USER}@${env.EC2_PRODUCTION_IP} << 'EOT'
//         set -ex

//         # Authenticate Docker to ECR (no explicit login required with IAM roles)
//         aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws

//         # Verify Production Image
//         docker run --rm \\
//             -d --name ${env.PROD_CONTAINER_NAME} \\
//             -e WORKDIR=${env.WORKDIR} \\
//             -e CONTAINER_APP_PORT=${env.CONTAINER_APP_PORT} \\
//             -e CHROME_DRIVER_VERSION=${env.CHROME_DRIVER_VERSION} \\
//             -e OUTPUT_FILE_PATH=${env.PROD_OUTPUT_FILE_PATH} \\
//             -p ${env.AWS_PROD_PORT}:${env.CONTAINER_APP_PORT} \\
//             ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT}

//         # List Docker images for verification
//         # echo "Docker images:"
//         # docker images

//         # Logout from Docker registry
//         docker logout ${env.DOCKER_REGISTRY}
// EOT
//                                 """
//                             }
//                         }
//                 } // script
//             } // steps
//         } // stage



    // stages
    }

    post {
            success {
                echo 'Success!'
                // Add notification here, e.g., Slack or email
            }
            failure {
                echo 'Failed!'
                // Add notification here, e.g., Slack or email
            }
            always {
               sh 'docker logout'
            }
        }

// pipeline
}

