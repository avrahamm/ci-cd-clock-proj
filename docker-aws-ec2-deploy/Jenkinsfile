pipeline {
    agent any
    environment {
        // Set from the global environment variable
        // to extract environment variables.
        JENKINS_ENV_FILE_PATH = "${env.JENKINS_ENV_FILE_PATH}"
    }

    stages {
        stage('Load Jenkins Environment Variables') {
            steps {
                script {
                    try {
                        def envFilePath = env.JENKINS_ENV_FILE_PATH
                        def props = readProperties file: envFilePath
                        env.DOCKER_HUB_CREDENTIALS_ID = props.DOCKER_HUB_CREDENTIALS_ID
                        env.CLOCK_PROJ_GIT_REPO_URL = props.CLOCK_PROJ_GIT_REPO_URL
                        env.CLOCK_PROJ_DOCKER_ENV_FILE_PATH = props.CLOCK_PROJ_DOCKER_ENV_FILE_PATH
                        env.CLOCK_PROJ_AWS_ENV_FILE_PATH = props.CLOCK_PROJ_AWS_ENV_FILE_PATH
                        env.GIT_CREDENTIALS_ID = props.GIT_CREDENTIALS_ID
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Load Jenkins Environment Variables'): ${e.message}")
                    }
                }
            }
        }

        stage('Load Docker Environment Variables') {
            steps {
                script {
                    try {
                        def dockerEnvProps = readProperties file: env.CLOCK_PROJ_DOCKER_ENV_FILE_PATH
                        env.CHROME_VERSION = dockerEnvProps.CHROME_VERSION
                        env.CHROME_DRIVER_VERSION = dockerEnvProps.CHROME_DRIVER_VERSION
                        env.CHROME_DRIVER_PATH = dockerEnvProps.CHROME_DRIVER_PATH
                        env.PYTHONPATH = dockerEnvProps.PYTHONPATH
                        env.SELENIUM_HEADLESS_MODE_DISPLAY_PORT = dockerEnvProps.SELENIUM_HEADLESS_MODE_DISPLAY_PORT
                        env.CONTAINER_APP_PORT = dockerEnvProps.CONTAINER_APP_PORT
                        env.PUBLISHED_TEST_APP_PORT = dockerEnvProps.PUBLISHED_TEST_APP_PORT
                        env.PUBLISHED_PROD_APP_PORT = dockerEnvProps.PUBLISHED_PROD_APP_PORT
                        env.IMAGE_NAME = dockerEnvProps.IMAGE_NAME
                        env.WORKDIR = dockerEnvProps.WORKDIR

                        env.UPDATE_CLOCK_TIME_INTERVAL = dockerEnvProps.UPDATE_CLOCK_TIME_INTERVAL
                        env.CLOCK_APP_URL = dockerEnvProps.CLOCK_APP_URL
                        env.REFRESH_INTERVAL = dockerEnvProps.REFRESH_INTERVAL
                        env.TIME_FORMAT = dockerEnvProps.TIME_FORMAT
                        env.TEST_OUTPUT_FILE_PATH = dockerEnvProps.TEST_OUTPUT_FILE_PATH
                        env.PROD_OUTPUT_FILE_PATH = dockerEnvProps.PROD_OUTPUT_FILE_PATH
                        env.TEST_CONTAINER_NAME = dockerEnvProps.TEST_CONTAINER_NAME
                        env.PROD_CONTAINER_NAME = dockerEnvProps.PROD_CONTAINER_NAME
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Load Docker Environment Variables'): ${e.message}")
                    }
                }
            }
        }

        stage('Load AWS Environment Variables') {
            steps {
                script {
                    try {
                        def awsEnvProps = readProperties file: env.CLOCK_PROJ_AWS_ENV_FILE_PATH
                        env.AWS_CREDENTIALS_ID = awsEnvProps.AWS_CREDENTIALS_ID
                        env.AWS_REGION = awsEnvProps.AWS_REGION
                        env.EC2_IP = awsEnvProps.EC2_IP
                        env.AWS_PROD_PORT = awsEnvProps.AWS_PROD_PORT
                        env.EC2_USER = awsEnvProps.EC2_USER
                        env.SSH_KEY_ID = awsEnvProps.SSH_KEY_ID

                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Load AWS Environment Variables'): ${e.message}")
                    }
                }
            }
        }

        stage('Git Clone Repo') {
            steps {
                script {
                    try {
                        echo 'Git Clone Repo'
                        git branch: 'main',
                            url: "${env.CLOCK_PROJ_GIT_REPO_URL}",
                            credentialsId: "${env.GIT_CREDENTIALS_ID}"
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Set Git Commit Hash'): ${e.message}")
                    }
                }
            }
        }

        stage('Set Git Commit Hash') {
            steps {
                script {
                    try {
                        env.GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                        echo "Short commit hash: ${env.GIT_COMMIT_SHORT}"
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Set Git Commit Hash'): ${e.message}")
                    }
                }
            }
        }

        stage('Login to Docker Hub') {
            steps {
                script {
                    try {
                        withCredentials([usernamePassword(
                            credentialsId: env.DOCKER_HUB_CREDENTIALS_ID,
                            usernameVariable: 'DOCKER_USERNAME',
                            passwordVariable: 'DOCKER_PASSWORD'
                          )]) {
                            sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin'
                        }
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Login to Docker Hub'): ${e.message}")
                    }
                }
            }
        }

        stage('Tester stage') {
            steps {
                script {
                    try {
                        echo 'Build docker images, run container and test'
                        sh """
                            docker --debug build --target tester \
                                   -t ${env.IMAGE_NAME}:test-${env.GIT_COMMIT_SHORT} .
                            docker run --rm \
                                -d --name ${env.TEST_CONTAINER_NAME} \
                                -e WORKDIR=${env.WORKDIR} \
                                -e CONTAINER_APP_PORT=${env.CONTAINER_APP_PORT} \
                                -e CHROME_DRIVER_VERSION=${env.CHROME_DRIVER_VERSION} \
                                -e OUTPUT_FILE_PATH=${env.TEST_OUTPUT_FILE_PATH} \
                                -p ${env.PUBLISHED_TEST_APP_PORT}:${env.CONTAINER_APP_PORT}  \
                                ${env.IMAGE_NAME}:test-${env.GIT_COMMIT_SHORT}
                        """
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Tester stage'): ${e.message}")
                    }
                }
            }
        }

        stage('Verify Production Image') {
            steps {
                script {
                    try {
                        echo 'Tests passed. Verify Production Image stage - build docker images and run container'
                        sh """
                            docker --debug build --target production \
                                   -t ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT} .
                            docker run --rm \
                                -d --name ${env.PROD_CONTAINER_NAME} \
                                -e WORKDIR=${env.WORKDIR} \
                                -e CONTAINER_APP_PORT=${env.CONTAINER_APP_PORT} \
                                -e CHROME_DRIVER_VERSION=${env.CHROME_DRIVER_VERSION} \
                                -e OUTPUT_FILE_PATH=${env.PROD_OUTPUT_FILE_PATH} \
                                -p ${env.PUBLISHED_PROD_APP_PORT}:${env.CONTAINER_APP_PORT}  \
                                ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT}
                           """
                        // Optional: Add a small delay to ensure everything is running
                        sleep 5
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Failed stage('Verify Production Image'): ${e.message}")
                    }
                }
            }
        }


        stage('Push docker images') {
            steps {
                script {
                    try {
                        echo 'Push test and production docker images'
                        sh """
                            docker images | grep clock || true
                            # docker image push ${env.IMAGE_NAME}:test-${env.GIT_COMMIT_SHORT}
                            # docker image push ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT}
                        """
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error "Failed on stage('Push docker images') : ${e.message}"
                    }
                }
            }
        }

        stage('Cleaning') {
            steps {
                script {
                    try {
                        echo 'Cleaning....'
                        sh """
                           docker stop ${env.TEST_CONTAINER_NAME} || true
                           docker stop ${env.PROD_CONTAINER_NAME} || true
                           docker rmi ${env.IMAGE_NAME}:test-${env.GIT_COMMIT_SHORT} || true
                           docker rmi ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT} || true
                           # Prune any dangling images
                           docker image prune -f || true
                        """
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error "Failed on stage('Cleaning'): ${e.message}"
                    }
                }
            }
        }

        stage('Deploy to EC2') {
            steps {
                script {
                    // AWS CLI commands will run in the Jenkins container
                    withAWS(credentials: env.AWS_CREDENTIALS_ID, region: env.AWS_REGION) {
                        // SSH into EC2 and deploy
                        sshagent(credentials: [env.SSH_KEY_ID]) {
                            sh """
                                ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} '
                                    # Install Docker if not already installed
                                    if ! command -v docker &> /dev/null; then
                                        sudo yum update -y
                                        sudo yum install -y docker
                                        sudo systemctl start docker
                                        sudo systemctl enable docker
                                        sudo usermod -aG docker ec2-user
                                    fi

                                    # Pull and run the new Docker image
                                    docker pull ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT}
                                    docker stop ${env.PROD_CONTAINER_NAME} || true
                                    docker rm ${env.PROD_CONTAINER_NAME} || true
                                    docker run -d --name ${env.PROD_CONTAINER_NAME} -p ${env.AWS_PROD_PORT}:${env.CONTAINER_APP_PORT} ${env.IMAGE_NAME}:production-${env.GIT_COMMIT_SHORT}

                                '
                            """
                        }
                    }
                }
            }

        }

    }



    post {
            success {
                echo 'Deployment successful!'
                // Add notification here, e.g., Slack or email
            }
            failure {
                echo 'Deployment failed!'
                // Add notification here, e.g., Slack or email
            }
            always {
               sh 'docker logout'
            }
        }
}

